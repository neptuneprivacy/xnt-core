/* XNT-SDK - C bindings for Neptune Privacy Core */
/* Generated by cbindgen - DO NOT EDIT */


#ifndef XNT_SDK_H
#define XNT_SDK_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// Error codes returned by FFI functions
typedef enum XntXntErrorCode {
    XNT_XNT_ERROR_CODE_OK = 0,
    XNT_XNT_ERROR_CODE_INVALID_INPUT = 1,
    XNT_XNT_ERROR_CODE_NULL_POINTER = 2,
    XNT_XNT_ERROR_CODE_INVALID_MNEMONIC = 3,
    XNT_XNT_ERROR_CODE_INVALID_ADDRESS = 4,
    XNT_XNT_ERROR_CODE_DECRYPTION_FAILED = 5,
    XNT_XNT_ERROR_CODE_ENCODING_FAILED = 6,
    XNT_XNT_ERROR_CODE_NETWORK_ERROR = 7,
    XNT_XNT_ERROR_CODE_INSUFFICIENT_FUNDS = 8,
    XNT_XNT_ERROR_CODE_PROOF_GENERATION_FAILED = 9,
    XNT_XNT_ERROR_CODE_DESERIALIZE_FAILED = 10,
    XNT_XNT_ERROR_CODE_RPC_ERROR = 11,
    XNT_XNT_ERROR_CODE_INTERNAL_ERROR = 99,
} XntXntErrorCode;

// Network type for address encoding (C-compatible)
typedef enum XntXntNetwork {
    XNT_XNT_NETWORK_MAIN = 0,
    XNT_XNT_NETWORK_TESTNET_MOCK = 1,
    XNT_XNT_NETWORK_REG_TEST = 2,
    XNT_XNT_NETWORK_TESTNET = 3,
} XntXntNetwork;

// Opaque handle to receiving address
typedef struct XntAddressHandle XntAddressHandle;

// Opaque handle to built transaction
typedef struct XntBuiltTransactionHandle XntBuiltTransactionHandle;

// Opaque handle to MembershipProof
typedef struct XntMsMembershipProofHandle XntMsMembershipProofHandle;

// Opaque handle to MutatorSet
typedef struct XntMutatorSetHandle XntMutatorSetHandle;

// Opaque handle to ReceivingAddress - use for transaction outputs
typedef struct XntReceivingAddressHandle XntReceivingAddressHandle;

// Opaque handle to RPC client
typedef struct XntRpcClientHandle XntRpcClientHandle;

// Opaque handle to spending key
typedef struct XntSpendingKeyHandle XntSpendingKeyHandle;

// Opaque handle to subaddress (address + payment_id)
typedef struct XntSubAddressHandle XntSubAddressHandle;

// Transaction builder handle
typedef struct XntTransactionBuilderHandle XntTransactionBuilderHandle;

// Opaque handle to final Transaction
typedef struct XntTransactionHandle XntTransactionHandle;

// Opaque handle to UTXO
typedef struct XntUtxoHandle XntUtxoHandle;

// Opaque handle to wallet entropy
typedef struct XntWalletEntropyHandle XntWalletEntropyHandle;

// XntDigest - 40 byte digest for FFI (TIP5 output)
typedef struct XntXntDigest {
    uint8_t bytes[40];
} XntXntDigest;

// Buffer for returning allocated byte arrays to C callers
typedef struct XntByteBuffer {
    uint8_t *data;
    uintptr_t len;
} XntByteBuffer;

// Indexed UTXO from sync (FFI-compatible)
typedef struct XntXntIndexedUtxo {
    uint64_t block_height;
    struct XntXntDigest block_digest;
    uint8_t *ciphertext_data;
    uintptr_t ciphertext_len;
} XntXntIndexedUtxo;

// Array of indexed UTXOs
typedef struct XntXntIndexedUtxoArray {
    struct XntXntIndexedUtxo *data;
    uintptr_t len;
} XntXntIndexedUtxoArray;

// Decrypted UTXO notification result
typedef struct XntXntDecryptedUtxo {
    struct XntUtxoHandle *utxo;
    struct XntXntDigest sender_randomness;
    uint64_t payment_id;
    uint64_t block_height;
    struct XntXntDigest block_digest;
} XntXntDecryptedUtxo;

// Spent status result
typedef struct XntXntSpentStatus {
    int64_t *heights;
    uintptr_t len;
} XntXntSpentStatus;

// AOCL indices result
typedef struct XntXntAoclIndices {
    int64_t *indices;
    uintptr_t len;
} XntXntAoclIndices;

// Transaction input info (C-compatible)
typedef struct XntXntTxInputInfo {
    struct XntUtxoHandle *utxo;
    struct XntXntDigest sender_randomness;
    struct XntXntDigest commitment;
    Xnti128 amount;
} XntXntTxInputInfo;

// Array of input info
typedef struct XntXntTxInputInfoArray {
    struct XntXntTxInputInfo *data;
    uintptr_t len;
} XntXntTxInputInfoArray;

// Transaction output info (C-compatible)
typedef struct XntXntTxOutputInfo {
    struct XntUtxoHandle *utxo;
    struct XntXntDigest sender_randomness;
    struct XntXntDigest receiver_digest;
    struct XntXntDigest commitment;
    Xnti128 amount;
    bool is_change;
    uint64_t payment_id;
} XntXntTxOutputInfo;

// Array of output info
typedef struct XntXntTxOutputInfoArray {
    struct XntXntTxOutputInfo *data;
    uintptr_t len;
} XntXntTxOutputInfoArray;

// Get receiving address from spending key
xnt_
struct XntAddressHandle *xnt_spending_key_to_address(const struct XntSpendingKeyHandle *handle);

// Encode address to bech32m string
xnt_ char *xnt_address_to_bech32(const struct XntAddressHandle *handle, enum XntXntNetwork network);

// Decode address from bech32m string
xnt_
struct XntAddressHandle *xnt_address_from_bech32(const char *bech32,
                                                 enum XntXntNetwork network);

// Get lock_script_hash from address (40 bytes)
xnt_
enum XntXntErrorCode xnt_address_lock_script_hash(const struct XntAddressHandle *handle,
                                                  uint8_t *out);

// Get receiver_identifier from address (8 bytes)
xnt_
enum XntXntErrorCode xnt_address_receiver_id(const struct XntAddressHandle *handle,
                                             uint8_t *out);

// Get receiver_identifier as hex string
xnt_ char *xnt_address_receiver_id_hex(const struct XntAddressHandle *handle);

// Get privacy_digest from address (40 bytes)
xnt_
enum XntXntErrorCode xnt_address_privacy_digest(const struct XntAddressHandle *handle,
                                                uint8_t *out);

// Create subaddress from address with payment_id
xnt_
struct XntSubAddressHandle *xnt_subaddress_create(const struct XntAddressHandle *address,
                                                  uint64_t payment_id);

// Encode subaddress to bech32m string
xnt_
char *xnt_subaddress_to_bech32(const struct XntSubAddressHandle *handle,
                               enum XntXntNetwork network);

// Get payment_id from subaddress
xnt_ uint64_t xnt_subaddress_payment_id(const struct XntSubAddressHandle *handle);

// Convert Address to ReceivingAddress
xnt_
struct XntReceivingAddressHandle *xnt_address_to_receiving(const struct XntAddressHandle *handle);

// Convert SubAddress to ReceivingAddress
xnt_
struct XntReceivingAddressHandle *xnt_subaddress_to_receiving(const struct XntSubAddressHandle *handle);

// Get payment_id (0 = main, non-zero = subaddress)
xnt_ uint64_t xnt_receiving_address_payment_id(const struct XntReceivingAddressHandle *handle);

// Hash arbitrary bytes with TIP5, output = 40 bytes (Digest)
// out: Buffer to write 40 bytes
xnt_ enum XntXntErrorCode xnt_tip5_hash(const uint8_t *data, uintptr_t data_len, uint8_t *out);

// Hash two digests with TIP5 (Merkle tree style), output = 40 bytes
xnt_
enum XntXntErrorCode xnt_tip5_hash_pair(const struct XntXntDigest *left,
                                        const struct XntXntDigest *right,
                                        uint8_t *out);

// Hash a single digest (self-hash), output = 40 bytes
xnt_ enum XntXntErrorCode xnt_tip5_hash_digest(const struct XntXntDigest *digest, uint8_t *out);

// SHAKE256 XOF - variable output length
// Returns allocated buffer, caller must free with xnt_buffer_free()
xnt_
struct XntByteBuffer *xnt_shake256(const uint8_t *data,
                                   uintptr_t data_len,
                                   uintptr_t output_len);

// SHAKE256 with fixed 32-byte output (common case for AES keys)
xnt_ enum XntXntErrorCode xnt_shake256_32(const uint8_t *data, uintptr_t data_len, uint8_t *out);

// AES-256-GCM encrypt
// key: 32 bytes, nonce: 12 bytes
// Returns encrypted ciphertext with auth tag, caller must free with xnt_buffer_free()
xnt_
struct XntByteBuffer *xnt_aes256gcm_encrypt(const uint8_t *key,
                                            const uint8_t *nonce,
                                            const uint8_t *plaintext,
                                            uintptr_t plaintext_len);

// AES-256-GCM decrypt
// key: 32 bytes, nonce: 12 bytes
// Returns decrypted plaintext, caller must free with xnt_buffer_free()
xnt_
struct XntByteBuffer *xnt_aes256gcm_decrypt(const uint8_t *key,
                                            const uint8_t *nonce,
                                            const uint8_t *ciphertext,
                                            uintptr_t ciphertext_len);

// Get last error message. Returns NULL if no error.
// Caller must NOT free this pointer.
xnt_ const char *xnt_get_last_error(void);

// Clear the last error message
xnt_ void xnt_clear_error(void);

// Get library version
xnt_ const char *xnt_version(void);

// Create RPC client
xnt_ struct XntRpcClientHandle *xnt_rpc_client_create(const char *url);

// Create RPC client with optional basic auth
xnt_
struct XntRpcClientHandle *xnt_rpc_client_create_with_auth(const char *url,
                                                           const char *username,
                                                           const char *password);

// Make a JSON-RPC call
// Returns result as JSON string, caller must free with xnt_string_free()
xnt_
char *xnt_rpc_call(const struct XntRpcClientHandle *client,
                   const char *method,
                   const char *params_json);

// Check if RPC client is connected (simple ping)
xnt_ enum XntXntErrorCode xnt_rpc_client_ping(const struct XntRpcClientHandle *client);

// Get current chain height
xnt_ int64_t xnt_rpc_chain_height(const struct XntRpcClientHandle *client);

// Generate new wallet with random 18-word mnemonic
xnt_ struct XntWalletEntropyHandle *xnt_wallet_generate(void);

// Create wallet from mnemonic phrase (space-separated words)
xnt_ struct XntWalletEntropyHandle *xnt_wallet_from_mnemonic(const char *mnemonic);

// Get devnet test wallet
xnt_ struct XntWalletEntropyHandle *xnt_wallet_devnet(void);

// Export wallet to mnemonic phrase
xnt_ char *xnt_wallet_to_mnemonic(const struct XntWalletEntropyHandle *handle);

// Derive Nth generation spending key
xnt_
struct XntSpendingKeyHandle *xnt_wallet_derive_key(const struct XntWalletEntropyHandle *handle,
                                                   uint64_t index);

// Get receiver_id from spending key
xnt_ uint64_t xnt_spending_key_receiver_id(const struct XntSpendingKeyHandle *handle);

// Get receiver_id as hex string
xnt_ char *xnt_spending_key_receiver_id_hex(const struct XntSpendingKeyHandle *handle);

// Get receiver_id_hash for indexer lookups (40 bytes)
xnt_
enum XntXntErrorCode xnt_spending_key_receiver_id_hash(const struct XntSpendingKeyHandle *handle,
                                                       uint8_t *out);

// Get receiver_id_hash as XntDigest
xnt_
struct XntXntDigest xnt_spending_key_receiver_id_hash_digest(const struct XntSpendingKeyHandle *handle);

// Get receiver preimage (privacy_preimage) for commitment computation (40 bytes)
xnt_
enum XntXntErrorCode xnt_spending_key_receiver_preimage(const struct XntSpendingKeyHandle *handle,
                                                        uint8_t *out);

// Get receiver preimage as hex string
xnt_ char *xnt_spending_key_receiver_preimage_hex(const struct XntSpendingKeyHandle *handle);

// Get receiver_id_hash as hex string
xnt_ char *xnt_spending_key_receiver_id_hash_hex(const struct XntSpendingKeyHandle *handle);

// Alias for xnt_wallet_derive_key (backwards compatibility)
xnt_
struct XntSpendingKeyHandle *xnt_wallet_derive_spending_key(const struct XntWalletEntropyHandle *handle,
                                                            uint64_t index);

// Fetch UTXOs by receiver_id_hash from indexer
xnt_
struct XntXntIndexedUtxoArray xnt_sync_fetch_utxos(const struct XntRpcClientHandle *client,
                                                   const struct XntXntDigest *receiver_id_hash,
                                                   uint64_t from_height,
                                                   uint64_t to_height);

// Free indexed UTXO array
xnt_ void xnt_sync_indexed_utxos_free(struct XntXntIndexedUtxoArray *arr);

// Decrypt indexed UTXO ciphertext with spending key
xnt_
struct XntXntDecryptedUtxo xnt_sync_decrypt_indexed_utxo(const struct XntSpendingKeyHandle *spending_key,
                                                         const struct XntXntIndexedUtxo *indexed_utxo);

// Check spent status of UTXOs by their absolute_index_set_hash
xnt_
struct XntXntSpentStatus xnt_sync_check_spent(const struct XntRpcClientHandle *client,
                                              const struct XntXntDigest *hashes,
                                              uintptr_t count);

// Free spent status result
xnt_ void xnt_sync_spent_status_free(struct XntXntSpentStatus *status);

// Get AOCL leaf indices for commitments
xnt_
struct XntXntAoclIndices xnt_sync_get_aocl_indices(const struct XntRpcClientHandle *client,
                                                   const struct XntXntDigest *commitments,
                                                   uintptr_t count);

// Free AOCL indices result
xnt_ void xnt_sync_aocl_indices_free(struct XntXntAoclIndices *result);

// Get current block height from node
xnt_ int64_t xnt_sync_get_height(const struct XntRpcClientHandle *client);

// Compute canonical commitment for UTXO (using receiver_preimage)
xnt_
enum XntXntErrorCode xnt_compute_commitment(const struct XntXntDigest *utxo_hash,
                                            const struct XntXntDigest *sender_randomness,
                                            const struct XntXntDigest *receiver_preimage,
                                            uint8_t *out_commitment);

// Compute canonical commitment for output (using receiver_postimage)
xnt_
enum XntXntErrorCode xnt_compute_commitment_for_output(const struct XntXntDigest *utxo_hash,
                                                       const struct XntXntDigest *sender_randomness,
                                                       const struct XntXntDigest *receiver_postimage,
                                                       uint8_t *out_commitment);

// Compute absolute_index_set_hash for spent checking
xnt_
enum XntXntErrorCode xnt_compute_absolute_index_set_hash(const struct XntXntDigest *utxo_hash,
                                                         const struct XntXntDigest *sender_randomness,
                                                         const struct XntXntDigest *receiver_preimage,
                                                         uint64_t aocl_leaf_index,
                                                         uint8_t *out_hash);

// Hash an AbsoluteIndexSet from JSON (from RPC mempool response)
// Used to check if a mempool tx input matches a known UTXO
xnt_ enum XntXntErrorCode xnt_hash_absolute_index_set(const char *json_str, uint8_t *out_hash);

// Get current mutator set accumulator from archival node
xnt_ struct XntMutatorSetHandle *xnt_sync_get_mutator_set(const struct XntRpcClientHandle *client);

// Serialize mutator set to bytes for caching
xnt_ struct XntByteBuffer *xnt_mutator_set_serialize(const struct XntMutatorSetHandle *handle);

// Deserialize mutator set from bytes
xnt_ struct XntMutatorSetHandle *xnt_mutator_set_deserialize(const uint8_t *data, uintptr_t len);

// Serialize membership proof to bytes
xnt_
struct XntByteBuffer *xnt_ms_membership_proof_serialize(const struct XntMsMembershipProofHandle *handle);

// Deserialize membership proof from bytes
xnt_
struct XntMsMembershipProofHandle *xnt_ms_membership_proof_deserialize(const uint8_t *data,
                                                                       uintptr_t len);

// Verify membership proof against mutator set
xnt_
bool xnt_verify_membership(const struct XntMutatorSetHandle *mutator_set,
                           const struct XntXntDigest *utxo_hash,
                           const struct XntMsMembershipProofHandle *membership_proof);

// Get the AOCL leaf index from a membership proof
xnt_ uint64_t xnt_ms_membership_proof_aocl_index(const struct XntMsMembershipProofHandle *handle);

// Get membership proofs for UTXOs via wallet RPC
xnt_
enum XntXntErrorCode xnt_sync_get_membership_proofs(const struct XntRpcClientHandle *client,
                                                    const struct XntXntDigest *utxo_hashes,
                                                    const struct XntXntDigest *sender_randomnesses,
                                                    const struct XntXntDigest *receiver_preimage,
                                                    const uint64_t *aocl_indices,
                                                    uintptr_t count,
                                                    struct XntMsMembershipProofHandle **out_proofs);

// Create new transaction builder
xnt_ struct XntTransactionBuilderHandle *xnt_tx_builder_create(void);

// Add input UTXO to spend
xnt_
enum XntXntErrorCode xnt_tx_builder_add_input(struct XntTransactionBuilderHandle *builder,
                                              const struct XntUtxoHandle *utxo,
                                              const struct XntSpendingKeyHandle *spending_key,
                                              const struct XntMsMembershipProofHandle *membership_proof);

// Add output (takes ReceivingAddress - works for both main and subaddresses)
xnt_
enum XntXntErrorCode xnt_tx_builder_add_output(struct XntTransactionBuilderHandle *builder,
                                               const struct XntReceivingAddressHandle *receiving_address,
                                               Xnti128 amount,
                                               const struct XntXntDigest *sender_randomness);

// Set change address
xnt_
enum XntXntErrorCode xnt_tx_builder_set_change(struct XntTransactionBuilderHandle *builder,
                                               const struct XntAddressHandle *change_address,
                                               const struct XntXntDigest *sender_randomness);

// Set transaction fee
xnt_
enum XntXntErrorCode xnt_tx_builder_set_fee(struct XntTransactionBuilderHandle *builder,
                                            Xnti128 fee);

// Get total input amount
xnt_ Xnti128 xnt_tx_builder_input_total(const struct XntTransactionBuilderHandle *builder);

// Get total output amount
xnt_ Xnti128 xnt_tx_builder_output_total(const struct XntTransactionBuilderHandle *builder);

// Get calculated change amount
xnt_ Xnti128 xnt_tx_builder_change_amount(const struct XntTransactionBuilderHandle *builder);

// Build the transaction
xnt_
struct XntBuiltTransactionHandle *xnt_tx_builder_build(const struct XntTransactionBuilderHandle *builder,
                                                       const struct XntMutatorSetHandle *mutator_set,
                                                       uint64_t timestamp_ms,
                                                       enum XntXntNetwork network);

// Prove the built transaction (creates ProofCollection)
// This is a blocking operation that can take significant time and memory
xnt_
struct XntTransactionHandle *xnt_built_transaction_prove(const struct XntBuiltTransactionHandle *handle);

// Get transaction kernel bytes
xnt_
struct XntByteBuffer *xnt_built_transaction_kernel(const struct XntBuiltTransactionHandle *handle);

// Get primitive witness bytes
xnt_
struct XntByteBuffer *xnt_built_transaction_witness(const struct XntBuiltTransactionHandle *handle);

// Serialize full transaction with Witness proof
xnt_
struct XntByteBuffer *xnt_built_transaction_serialize(const struct XntBuiltTransactionHandle *handle);

// Deserialize Transaction
xnt_ struct XntTransactionHandle *xnt_transaction_deserialize(const uint8_t *data, uintptr_t len);

// Serialize Transaction for broadcast
xnt_ struct XntByteBuffer *xnt_transaction_serialize(const struct XntTransactionHandle *handle);

// Check if transaction has ProofCollection
xnt_ bool xnt_transaction_has_proof_collection(const struct XntTransactionHandle *handle);

// Check if transaction has SingleProof
xnt_ bool xnt_transaction_has_single_proof(const struct XntTransactionHandle *handle);

// Submit transaction to node via RPC
xnt_
enum XntXntErrorCode xnt_transaction_submit(const struct XntTransactionHandle *handle,
                                            const struct XntRpcClientHandle *client);

// Get current timestamp in milliseconds
xnt_ uint64_t xnt_timestamp_now(void);

// Select UTXOs to cover target amount (smallest-first)
// out_indices: buffer to write selected indices, must have capacity >= limit
// out_capacity: capacity of out_indices buffer (must be >= limit)
// Returns count of selected indices, writes indices to out_indices
// Returns -1 on error
xnt_
int32_t xnt_select_inputs(const Xnti128 *amounts,
                          uintptr_t amounts_len,
                          Xnti128 target,
                          uintptr_t limit,
                          uintptr_t *out_indices,
                          uintptr_t out_capacity);

// Generate random sender_randomness as XntDigest
xnt_ struct XntXntDigest xnt_random_sender_randomness(void);

// Generate random sender_randomness as hex string
xnt_ char *xnt_random_sender_randomness_hex(void);

// Get all inputs from built transaction
xnt_
struct XntXntTxInputInfoArray *xnt_built_transaction_inputs(const struct XntBuiltTransactionHandle *handle);

// Get all outputs from built transaction
xnt_
struct XntXntTxOutputInfoArray *xnt_built_transaction_outputs(const struct XntBuiltTransactionHandle *handle);

// Free input info array
xnt_ void xnt_tx_input_info_array_free(struct XntXntTxInputInfoArray *arr);

// Free output info array
xnt_ void xnt_tx_output_info_array_free(struct XntXntTxOutputInfoArray *arr);

// Free a byte buffer allocated by xnt-ffi
//
// # Safety
// - Must only be called once per buffer
// - Caller must NOT use the buffer after calling this function
// - Calling twice on same buffer causes undefined behavior (double-free)
xnt_ void xnt_bytes_free(struct XntByteBuffer buf);

// Free a string allocated by xnt-ffi
//
// # Safety
// - Must only be called once per string
// - Caller must NOT use the string after calling this function
// - Calling twice on same pointer causes undefined behavior (double-free)
xnt_ void xnt_string_free(char *ptr);

// Free ByteBuffer pointer allocated by xnt-ffi
//
// # Safety
// - Must only be called once per buffer
// - Caller must NOT use the buffer after calling this function
// - Calling twice on same pointer causes undefined behavior (double-free)
xnt_ void xnt_buffer_free(struct XntByteBuffer *buf);

// Create UTXO for native currency
xnt_
struct XntUtxoHandle *xnt_utxo_create_native(const struct XntAddressHandle *address,
                                             Xnti128 amount);

// Get native currency amount from UTXO (in nau)
xnt_ Xnti128 xnt_utxo_get_amount(const struct XntUtxoHandle *handle);

// Get lock_script_hash from UTXO (40 bytes)
xnt_
enum XntXntErrorCode xnt_utxo_lock_script_hash(const struct XntUtxoHandle *handle,
                                               uint8_t *out);

// Get UTXO hash (40 bytes)
xnt_ enum XntXntErrorCode xnt_utxo_hash(const struct XntUtxoHandle *handle, uint8_t *out);

// Serialize UTXO to bytes
xnt_ struct XntByteBuffer *xnt_utxo_serialize(const struct XntUtxoHandle *handle);

// Deserialize UTXO from bytes
xnt_ struct XntUtxoHandle *xnt_utxo_deserialize(const uint8_t *data, uintptr_t len);

// Get release date if UTXO is timelocked (milliseconds since Unix epoch)
// Returns 0 if not timelocked
xnt_ uint64_t xnt_utxo_release_date(const struct XntUtxoHandle *handle);

// Check if UTXO is timelocked (returns 1 if timelocked, 0 if not)
xnt_ int32_t xnt_utxo_is_timelocked(const struct XntUtxoHandle *handle);

// Check if UTXO can be spent at given timestamp (milliseconds since Unix epoch)
// Returns 1 if can spend, 0 if not
xnt_ int32_t xnt_utxo_can_spend_at(const struct XntUtxoHandle *handle, uint64_t timestamp_ms);

// Add timelock to UTXO, returns new timelocked UTXO handle
xnt_
struct XntUtxoHandle *xnt_utxo_with_time_lock(const struct XntUtxoHandle *handle,
                                              uint64_t release_date_ms);

// Decrypt announcement with spending key
xnt_
struct XntXntDecryptedUtxo xnt_announcement_decrypt(const struct XntSpendingKeyHandle *spending_key,
                                                    const uint8_t *announcement_data,
                                                    uintptr_t announcement_count);

// Free decrypted UTXO result
xnt_ void xnt_decrypted_utxo_free(struct XntXntDecryptedUtxo *result);

#endif  /* XNT_SDK_H */
