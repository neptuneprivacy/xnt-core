/* XNT-FFI - C bindings for Neptune Privacy Core */
/* Generated by cbindgen - DO NOT EDIT */


#ifndef XNT_FFI_H
#define XNT_FFI_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// Error codes returned by FFI functions
typedef enum XntErrorCode {
    OK = 0,
    INVALID_INPUT = 1,
    NULL_POINTER = 2,
    INVALID_MNEMONIC = 3,
    INVALID_ADDRESS = 4,
    DECRYPTION_FAILED = 5,
    ENCODING_FAILED = 6,
    NETWORK_ERROR = 7,
    INSUFFICIENT_FUNDS = 8,
    PROOF_GENERATION_FAILED = 9,
    DESERIALIZE_FAILED = 10,
    RPC_ERROR = 11,
    INTERNAL_ERROR = 99,
} XntErrorCode;

// Network type for address encoding
typedef enum XntNetwork {
    MAIN = 0,
    TESTNET_MOCK = 1,
    REG_TEST = 2,
    TESTNET = 3,
} XntNetwork;

// Opaque handle to receiving address (Generation or Symmetric)
typedef struct AddressHandle AddressHandle;

// Opaque handle to built transaction data
typedef struct BuiltTransactionHandle BuiltTransactionHandle;

// Opaque handle to MsMembershipProof
typedef struct MsMembershipProofHandle MsMembershipProofHandle;

// Opaque handle to MutatorSetAccumulator
typedef struct MutatorSetHandle MutatorSetHandle;

// JSON-RPC client handle
typedef struct RpcClientHandle RpcClientHandle;

// Opaque handle to spending key (Generation or Symmetric)
typedef struct SpendingKeyHandle SpendingKeyHandle;

// Opaque handle to subaddress (address + payment_id)
typedef struct SubAddressHandle SubAddressHandle;

// Transaction builder - collects inputs and outputs, auto-calculates change
typedef struct TransactionBuilderHandle TransactionBuilderHandle;

// Opaque handle to final Transaction
typedef struct TransactionHandle TransactionHandle;

// Opaque handle to UTXO
typedef struct UtxoHandle UtxoHandle;

// Opaque handle to wallet entropy (secret seed)
typedef struct WalletHandle WalletHandle;

// XntDigest - 40 byte digest for FFI (TIP5 output)
typedef struct XntDigest {
    uint8_t bytes[40];
} XntDigest;

// Buffer for returning allocated byte arrays to C callers
typedef struct ByteBuffer {
    uint8_t *data;
    uintptr_t len;
} ByteBuffer;

// Indexed UTXO from sync (FFI-compatible)
typedef struct XntIndexedUtxo {
    uint64_t block_height;
    struct XntDigest block_digest;
    uint8_t *ciphertext_data;
    uintptr_t ciphertext_len;
} XntIndexedUtxo;

// Array of indexed UTXOs
typedef struct XntIndexedUtxoArray {
    struct XntIndexedUtxo *data;
    uintptr_t len;
} XntIndexedUtxoArray;

// Decrypted UTXO notification result
typedef struct XntDecryptedUtxo {
    struct UtxoHandle *utxo;
    struct XntDigest sender_randomness;
    uint64_t payment_id;
} XntDecryptedUtxo;

// Spent status result
typedef struct XntSpentStatus {
    int64_t *heights;
    uintptr_t len;
} XntSpentStatus;

// AOCL indices result
typedef struct XntAoclIndices {
    int64_t *indices;
    uintptr_t len;
} XntAoclIndices;

// Library version
const char *xnt_version(void);

// Get receiving address from spending key
struct AddressHandle *xnt_spending_key_to_address(const struct SpendingKeyHandle *handle);

// Encode address to bech32m string
// Caller must free with xnt_string_free()
char *xnt_address_to_bech32(const struct AddressHandle *handle, enum XntNetwork network);

// Decode address from bech32m string
struct AddressHandle *xnt_address_from_bech32(const char *bech32, enum XntNetwork network);

// Get lock_script_hash from address (40 bytes = Digest)
enum XntErrorCode xnt_address_lock_script_hash(const struct AddressHandle *handle, uint8_t *out);

// Get receiver_identifier from address (8 bytes = BFieldElement)
enum XntErrorCode xnt_address_receiver_id(const struct AddressHandle *handle, uint8_t *out);

// Get receiver_identifier from address as hex string
// Caller must free with xnt_string_free()
char *xnt_address_receiver_id_hex(const struct AddressHandle *handle);

// Get privacy_digest (receiver_postimage) from address (40 bytes)
// This is used to compute output commitments
enum XntErrorCode xnt_address_privacy_digest(const struct AddressHandle *handle, uint8_t *out);

// Create subaddress from address with payment_id
// payment_id must be non-zero
// Only works for Generation addresses
struct SubAddressHandle *xnt_subaddress_create(const struct AddressHandle *address,
                                               uint64_t payment_id);

// Encode subaddress to bech32m string
// Caller must free with xnt_string_free()
char *xnt_subaddress_to_bech32(const struct SubAddressHandle *handle, enum XntNetwork network);

// Get payment_id from subaddress
uint64_t xnt_subaddress_payment_id(const struct SubAddressHandle *handle);

// Hash arbitrary bytes with TIP5, output = 40 bytes (Digest)
// out: Buffer to write 40 bytes
enum XntErrorCode xnt_tip5_hash(const uint8_t *data, uintptr_t data_len, uint8_t *out);

// Hash two digests with TIP5 (Merkle tree style), output = 40 bytes
enum XntErrorCode xnt_tip5_hash_pair(const struct XntDigest *left,
                                     const struct XntDigest *right,
                                     uint8_t *out);

// Hash a single digest (self-hash), output = 40 bytes
enum XntErrorCode xnt_tip5_hash_digest(const struct XntDigest *digest, uint8_t *out);

// SHAKE256 XOF - variable output length
// Returns allocated buffer, caller must free with xnt_buffer_free()
struct ByteBuffer *xnt_shake256(const uint8_t *data, uintptr_t data_len, uintptr_t output_len);

// SHAKE256 with fixed 32-byte output (common case for AES keys)
enum XntErrorCode xnt_shake256_32(const uint8_t *data, uintptr_t data_len, uint8_t *out);

// AES-256-GCM encrypt
// key: 32 bytes, nonce: 12 bytes
// Returns encrypted ciphertext with auth tag, caller must free with xnt_buffer_free()
struct ByteBuffer *xnt_aes256gcm_encrypt(const uint8_t *key,
                                         const uint8_t *nonce,
                                         const uint8_t *plaintext,
                                         uintptr_t plaintext_len);

// AES-256-GCM decrypt
// key: 32 bytes, nonce: 12 bytes
// Returns decrypted plaintext, caller must free with xnt_buffer_free()
struct ByteBuffer *xnt_aes256gcm_decrypt(const uint8_t *key,
                                         const uint8_t *nonce,
                                         const uint8_t *ciphertext,
                                         uintptr_t ciphertext_len);

// Convert bytes to BFieldElements encoding
// Returns allocated buffer containing BFE values (8 bytes each, little-endian)
// Caller must free with xnt_buffer_free()
struct ByteBuffer *xnt_bytes_to_bfes(const uint8_t *data, uintptr_t data_len);

// Convert BFieldElements back to bytes
// bfes_data: Buffer of BFE values (8 bytes each, little-endian)
// Returns decoded bytes, caller must free with xnt_buffer_free()
struct ByteBuffer *xnt_bfes_to_bytes(const uint8_t *bfes_data, uintptr_t bfes_len);

// Get last error message. Returns NULL if no error.
// Caller must NOT free this pointer.
const char *xnt_get_last_error(void);

// Clear the last error message
void xnt_clear_error(void);

// Create RPC client
struct RpcClientHandle *xnt_rpc_client_create(const char *url);

// Create RPC client with optional basic auth
struct RpcClientHandle *xnt_rpc_client_create_with_auth(const char *url,
                                                        const char *username,
                                                        const char *password);

// Make a JSON-RPC call (FFI wrapper)
// Returns result as JSON string, caller must free with xnt_string_free()
char *xnt_rpc_call(const struct RpcClientHandle *client,
                   const char *method,
                   const char *params_json);

// Check if RPC client is connected (simple ping via chain_height)
enum XntErrorCode xnt_rpc_client_ping(const struct RpcClientHandle *client);

// Get current chain height
int64_t xnt_rpc_chain_height(const struct RpcClientHandle *client);

// Generate a new random wallet with 18-word mnemonic
// Returns NULL on failure, check xnt_get_last_error()
struct WalletHandle *xnt_wallet_generate(void);

// Create wallet from 18-word mnemonic phrase (space-separated)
// Returns NULL on failure
struct WalletHandle *xnt_wallet_from_mnemonic(const char *mnemonic);

// Export wallet to 18-word mnemonic phrase (space-separated)
// Caller must free returned string with xnt_string_free()
char *xnt_wallet_to_mnemonic(const struct WalletHandle *handle);

// Derive Nth generation spending key from wallet
// index: Key derivation index (0 = guesser/composer fee key)
struct SpendingKeyHandle *xnt_wallet_derive_spending_key(const struct WalletHandle *handle,
                                                         uint64_t index);

// Get receiver identifier from spending key (8 bytes, little-endian u64)
// out: Buffer to write 8 bytes
enum XntErrorCode xnt_spending_key_receiver_id(const struct SpendingKeyHandle *handle,
                                               uint8_t *out);

// Get receiver identifier as hex string
// Caller must free returned string with xnt_string_free()
char *xnt_spending_key_receiver_id_hex(const struct SpendingKeyHandle *handle);

// Get receiver_id_hash (TIP5 hash of receiver_identifier) for indexer lookups
// out: Buffer to write 40 bytes (Digest)
enum XntErrorCode xnt_spending_key_receiver_id_hash(const struct SpendingKeyHandle *handle,
                                                    uint8_t *out);

// Fetch UTXOs by receiver_id_hash from indexer
struct XntIndexedUtxoArray xnt_sync_fetch_utxos(const struct RpcClientHandle *client,
                                                const struct XntDigest *receiver_id_hash,
                                                uint64_t from_height,
                                                uint64_t to_height);

// Free indexed UTXO array
void xnt_sync_indexed_utxos_free(struct XntIndexedUtxoArray *arr);

// Decrypt indexed UTXO ciphertext with spending key
struct XntDecryptedUtxo xnt_sync_decrypt_indexed_utxo(const struct SpendingKeyHandle *spending_key,
                                                      const struct XntIndexedUtxo *indexed_utxo);

// Check spent status of UTXOs by their absolute_index_set_hash
struct XntSpentStatus xnt_sync_check_spent(const struct RpcClientHandle *client,
                                           const struct XntDigest *hashes,
                                           uintptr_t count);

// Free spent status result
void xnt_sync_spent_status_free(struct XntSpentStatus *status);

// Get AOCL leaf indices for commitments
struct XntAoclIndices xnt_sync_get_aocl_indices(const struct RpcClientHandle *client,
                                                const struct XntDigest *commitments,
                                                uintptr_t count);

// Free AOCL indices result
void xnt_sync_aocl_indices_free(struct XntAoclIndices *result);

// Get current block height from node
int64_t xnt_sync_get_height(const struct RpcClientHandle *client);

// Compute canonical commitment for UTXO (using receiver_preimage)
// Use this for inputs where you have the receiver's preimage
enum XntErrorCode xnt_compute_commitment(const struct XntDigest *utxo_hash,
                                         const struct XntDigest *sender_randomness,
                                         const struct XntDigest *receiver_preimage,
                                         uint8_t *out_commitment);

// Compute canonical commitment for UTXO (using receiver_postimage/privacy_digest)
// Use this for outputs where you have the receiver's address (privacy_digest)
enum XntErrorCode xnt_compute_commitment_for_output(const struct XntDigest *utxo_hash,
                                                    const struct XntDigest *sender_randomness,
                                                    const struct XntDigest *receiver_postimage,
                                                    uint8_t *out_commitment);

// Compute absolute_index_set_hash for spent checking
enum XntErrorCode xnt_compute_absolute_index_set_hash(const struct XntDigest *utxo_hash,
                                                      const struct XntDigest *sender_randomness,
                                                      const struct XntDigest *receiver_preimage,
                                                      uint64_t aocl_leaf_index,
                                                      uint8_t *out_hash);

// Compute absolute_index_set raw data for debugging
enum XntErrorCode xnt_compute_absolute_index_set_raw(const struct XntDigest *utxo_hash,
                                                     const struct XntDigest *sender_randomness,
                                                     const struct XntDigest *receiver_preimage,
                                                     uint64_t aocl_leaf_index,
                                                     u128 *minimum_out,
                                                     uint32_t *distances_out);

// Get receiver_preimage from spending key (40 bytes)
enum XntErrorCode xnt_spending_key_receiver_preimage(const struct SpendingKeyHandle *handle,
                                                     uint8_t *out);

// Compute UTXO hash (TIP5 hash of UTXO for commitment calculation)
enum XntErrorCode xnt_utxo_hash(const struct UtxoHandle *utxo, uint8_t *out);

// Compute hash of AbsoluteIndexSet from raw data (for testing)
enum XntErrorCode xnt_compute_abs_hash_from_raw(u128 minimum,
                                                const uint32_t *distances,
                                                uint8_t *out_hash);

// Get current mutator set accumulator from archival node
struct MutatorSetHandle *xnt_sync_get_mutator_set(const struct RpcClientHandle *client);

// Serialize mutator set to bytes for caching
struct ByteBuffer *xnt_mutator_set_serialize(const struct MutatorSetHandle *handle);

// Deserialize mutator set from bytes
struct MutatorSetHandle *xnt_mutator_set_deserialize(const uint8_t *data, uintptr_t len);

// Serialize membership proof to bytes (for caching or transport)
struct ByteBuffer *xnt_ms_membership_proof_serialize(const struct MsMembershipProofHandle *handle);

// Deserialize membership proof from bytes
struct MsMembershipProofHandle *xnt_ms_membership_proof_deserialize(const uint8_t *data,
                                                                    uintptr_t len);

// Verify membership proof against mutator set
bool xnt_verify_membership(const struct MutatorSetHandle *mutator_set,
                           const struct XntDigest *utxo_hash,
                           const struct MsMembershipProofHandle *membership_proof);

// Get the AOCL leaf index from a membership proof
uint64_t xnt_ms_membership_proof_aocl_index(const struct MsMembershipProofHandle *handle);

// Get membership proofs for multiple UTXOs in one RPC call
// Returns array of MsMembershipProofHandle pointers (same order as input)
// utxo_hashes, sender_randomnesses, aocl_leaf_indices: parallel arrays of count elements
// receiver_preimage: shared for all UTXOs (same spending key)
enum XntErrorCode xnt_sync_get_membership_proofs(const struct RpcClientHandle *client,
                                                 const struct XntDigest *utxo_hashes,
                                                 const struct XntDigest *sender_randomnesses,
                                                 const struct XntDigest *receiver_preimage,
                                                 const uint64_t *aocl_leaf_indices,
                                                 uintptr_t count,
                                                 struct MsMembershipProofHandle **out_proofs);

// Create new transaction builder
struct TransactionBuilderHandle *xnt_tx_builder_create(void);

// Add input UTXO to spend (clones the handles, caller keeps ownership)
enum XntErrorCode xnt_tx_builder_add_input(struct TransactionBuilderHandle *builder,
                                           const struct UtxoHandle *utxo,
                                           const struct SpendingKeyHandle *spending_key,
                                           const struct MsMembershipProofHandle *membership_proof);

// Add output recipient
enum XntErrorCode xnt_tx_builder_add_output(struct TransactionBuilderHandle *builder,
                                            const struct AddressHandle *address,
                                            i128 amount,
                                            const struct XntDigest *sender_randomness);

// Set change address (required if inputs > outputs + fee)
enum XntErrorCode xnt_tx_builder_set_change(struct TransactionBuilderHandle *builder,
                                            const struct AddressHandle *change_address,
                                            const struct XntDigest *sender_randomness);

// Set transaction fee
enum XntErrorCode xnt_tx_builder_set_fee(struct TransactionBuilderHandle *builder, i128 fee);

// Get total input amount
i128 xnt_tx_builder_input_total(const struct TransactionBuilderHandle *builder);

// Get total output amount (excluding change)
i128 xnt_tx_builder_output_total(const struct TransactionBuilderHandle *builder);

// Get calculated change amount (inputs - outputs - fee)
i128 xnt_tx_builder_change_amount(const struct TransactionBuilderHandle *builder);

// Build the transaction - creates TransactionDetails and PrimitiveWitness
// Returns null if validation fails (check xnt_get_last_error)
struct BuiltTransactionHandle *xnt_tx_builder_build(const struct TransactionBuilderHandle *builder,
                                                    const struct MutatorSetHandle *mutator_set,
                                                    uint64_t timestamp_ms,
                                                    enum XntNetwork network);

// Get transaction kernel (public data)
struct ByteBuffer *xnt_built_transaction_kernel(const struct BuiltTransactionHandle *handle);

// Get primitive witness (secret data for prover)
struct ByteBuffer *xnt_built_transaction_witness(const struct BuiltTransactionHandle *handle);

// Get full transaction with Witness proof (for sending to prover)
struct ByteBuffer *xnt_built_transaction_serialize(const struct BuiltTransactionHandle *handle);

// Create ProofCollection from built transaction (blocking, ~16GB RAM)
// Returns Transaction with ProofCollection proof, ready for SingleProof upgrade
struct TransactionHandle *xnt_built_transaction_prove(const struct BuiltTransactionHandle *handle);

// Deserialize Transaction (received from prover with SingleProof)
struct TransactionHandle *xnt_transaction_deserialize(const uint8_t *data, uintptr_t len);

// Serialize Transaction for broadcast
struct ByteBuffer *xnt_transaction_serialize(const struct TransactionHandle *handle);

// Check if transaction has ProofCollection (locally proven, needs SingleProof for broadcast)
bool xnt_transaction_has_proof_collection(const struct TransactionHandle *handle);

// Check if transaction has SingleProof (ready for broadcast)
bool xnt_transaction_has_single_proof(const struct TransactionHandle *handle);

// Get current timestamp in milliseconds
uint64_t xnt_timestamp_now(void);

// Submit transaction to node via JSON-RPC (mempool_submitTransaction)
//
// Parameters:
// - handle: Transaction to submit (must have ProofCollection or SingleProof)
// - client: RPC client handle from xnt_rpc_client_create()
//
// Returns XntErrorCode::Ok on success, error code on failure.
// Check xnt_get_last_error() for details on failure.
enum XntErrorCode xnt_transaction_submit(const struct TransactionHandle *handle,
                                         const struct RpcClientHandle *client);

// Free a byte buffer allocated by xnt-ffi
void xnt_bytes_free(struct ByteBuffer buf);

// Free a string allocated by xnt-ffi
void xnt_string_free(char *ptr);

// Free ByteBuffer pointer allocated by xnt-ffi
void xnt_buffer_free(struct ByteBuffer *buf);

// Create UTXO for native currency
// amount: native currency amount in atomic units (nau)
struct UtxoHandle *xnt_utxo_create_native(const struct AddressHandle *address, i128 amount);

// Get native currency amount from UTXO (in atomic units - nau)
i128 xnt_utxo_get_amount(const struct UtxoHandle *handle);

// Get lock_script_hash from UTXO (40 bytes = Digest)
enum XntErrorCode xnt_utxo_lock_script_hash(const struct UtxoHandle *handle, uint8_t *out);

// Serialize UTXO to bytes (bincode format)
// Caller must free with xnt_buffer_free()
struct ByteBuffer *xnt_utxo_serialize(const struct UtxoHandle *handle);

// Deserialize UTXO from bytes (bincode format)
struct UtxoHandle *xnt_utxo_deserialize(const uint8_t *data, uintptr_t len);

// Try to decrypt announcement with spending key
// Returns decrypted UTXO info or null UTXO on failure
// announcement_data: BFieldElement array (8 bytes per element, little-endian)
// announcement_count: number of BFieldElements
struct XntDecryptedUtxo xnt_announcement_decrypt(const struct SpendingKeyHandle *spending_key,
                                                 const uint8_t *announcement_data,
                                                 uintptr_t announcement_count);

// Free decrypted UTXO result (only the UTXO handle)
void xnt_decrypted_utxo_free(struct XntDecryptedUtxo *result);

#endif  /* XNT_FFI_H */
